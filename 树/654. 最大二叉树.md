## [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

1. 递归 时间复杂度o(n) 空间复杂度o(n)
```ts
function constructMaximumBinaryTree(nums: number[]): TreeNode | null {
    return traverse(nums, 0, nums.length - 1);
};
function traverse(nums, left, right) {
    if (left > right) return null;
    let [max, idx] = nums.slice(left, right + 1).reduce(([max, idx], val, index) => {
        if (max < val) {
            return [val, index];
        } else {
            return [max, idx];
        }
    }, [-1]);
    idx += left;
    let root = new TreeNode(max);
    root.left = traverse(nums, left, idx - 1);
    root.right = traverse(nums, idx + 1, right);
    return root;
}
```